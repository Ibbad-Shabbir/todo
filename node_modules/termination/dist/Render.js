"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.EVENTS = void 0;

var _os = require("os");

var _events = require("events");

var _Terminal = _interopRequireWildcard(require("./Terminal"));

var _ObjectsManager = _interopRequireDefault(require("./ObjectsManager"));

var _utils = require("./utils");

require("colors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BASE_TIMER_KEY = 'BASE';
var EVENTS = {
  WILL_RENDER: 'willrender',
  RENDER: 'render'
};
exports.EVENTS = EVENTS;

class Render extends _events.EventEmitter {
  constructor(ObjectsManager) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super();

    _defineProperty(this, "defaults", {
      fps: 30,
      maxSize: {}
    });

    var {
      fps = this.defaults.fps,
      maxSize = this.defaults.maxSize,
      speed = 1,
      bg = {}
    } = props;
    (0, _utils.validateInstance)(ObjectsManager, _ObjectsManager.default);
    this.renderExecutor = this.renderExecutor.bind(this);
    this.handleResize = this.handleResize.bind(this);
    this.Terminal = new _Terminal.default();
    this.ObjectsManager = ObjectsManager;
    this.fps = fps;
    this.speed = speed;
    this.maxSize = maxSize;
    this.bg = bg;
    this.isPlaying = false;
    this.lastPrinted = '';
    this.timers = {};
    this.Terminal.setCursorVisibility(true);
  }

  cleanUp() {
    this.Terminal.removeListener(_Terminal.EVENTS.RESIZE, this.handleResize);
    (0, _utils.objToArray)(this.timers).forEach(timer => clearTimeout(timer));
  }

  subscribeListeners() {
    this.Terminal.on(_Terminal.EVENTS.RESIZE, this.handleResize);
  }

  handleResize(width, height) {
    this.setSize(width, height, true);
  }

  setSize() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Terminal.getWidth();
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.Terminal.getHeight();
    var {
      height: maxHeight,
      width: maxWidth
    } = this.maxSize;
    var finalHeight = maxHeight ? Math.min(height, maxHeight) : height;
    var finalWidth = maxWidth ? Math.min(width, maxWidth) : width;
    this.size = {
      width: finalWidth,
      height: finalHeight
    };
  }

  renderExecutor(noClear) {
    this.render(noClear);

    if (this.isPlaying) {
      clearTimeout(this.timers[BASE_TIMER_KEY]);
      this.timers[BASE_TIMER_KEY] = setTimeout(this.renderExecutor, parseInt(1000 / this.fps));
    }
  }

  getRenderMap() {
    var out = {};
    var timePassed = this.speed * 1000 / this.fps;
    var objects = this.ObjectsManager.getObjects(timePassed);

    for (var objKey in objects) {
      var object = objects[objKey];
      var replaceSpace = object.state.replaceSpace;

      if (!object) {
        continue;
      }

      var {
        x,
        y,
        lines,
        color
      } = object.state;

      for (var lineIndex in lines) {
        lineIndex = parseInt(lineIndex);
        var line = lines[lineIndex];

        for (var i = 0; i < line.length; i++) {
          if (replaceSpace && line[i] === ' ') {
            continue;
          }

          this.setRenderMapCell(out, x + i, y + lineIndex, line[i], color);
        }
      }
    }

    return out;
  }

  setRenderMapCell(obj, x, y, chr, color) {
    var roundX = Math.round(x);
    var roundY = Math.round(y);

    if (!obj[roundY]) {
      obj[roundY] = {};
    }

    obj[roundY][roundX] = color ? chr[color] : chr;
  }

  render(noClear) {
    this.emit(EVENTS.WILL_RENDER);
    var {
      height,
      width
    } = this.size;
    var renderMap = this.getRenderMap();
    var renderString = '';
    var bgChar = this.bg.char || ' ';
    var color = this.bg.color;
    var coloredBgChar = bgChar && bgChar.trim() && color ? bgChar[color] : bgChar;

    for (var y = 0; y < height; y++) {
      var isLastLine = y === height - 1;

      for (var x = 0; x < width; x++) {
        var chr = renderMap[y] ? renderMap[y][x] || coloredBgChar : coloredBgChar;
        renderString += chr;
      }

      if (!isLastLine) {
        renderString += _os.EOL;
      }
    }

    this.paint(renderString, noClear);
    this.emit(EVENTS.RENDER, renderString);
  }

  paint(str, noClear) {
    if (str === this.lastPrinted) {
      return;
    }

    if (!noClear) {
      this.Terminal.clear();
    }

    this.Terminal.write(str);
    this.lastPrinted = str;
  }
  /**
   * External
   */


  config(_ref) {
    var {
      fps = this.fps,
      maxSize = this.maxSize,
      speed = this.speed,
      bg = {}
    } = _ref;
    this.fps = fps;
    this.maxSize = maxSize;
    this.speed = speed;
    this.bg = _objectSpread(_objectSpread({}, this.bg), bg);
  }

  resume(append) {
    if (this.isPlaying) {
      return;
    }

    this.isPlaying = true;
    this.Terminal.setCursorVisibility(false);
    this.setSize();
    this.subscribeListeners();
    this.renderExecutor(append);
  }

  pause(clear) {
    if (!this.isPlaying) {
      return;
    }

    this.isPlaying = false;
    this.Terminal.setCursorVisibility(true);
    this.cleanUp();

    if (clear) {
      this.Terminal.clear();
    }
  }

  end(clear) {
    this.isPlaying = false;
    this.cleanUp();
    this.timers = {};
    this.Terminal.setCursorVisibility(true);

    if (clear) {
      this.Terminal.clear();
    } else {
      this.Terminal.write(_os.EOL);
    }
  }

}

exports.default = Render;