"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.definedOnly = definedOnly;
exports.firstDefined = firstDefined;
exports.merge = merge;
exports.objToArray = objToArray;
exports.selectProps = selectProps;
exports.validateInstance = validateInstance;
exports.wait = wait;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * convert object to array of values
 * @param  {Object} obj
 * @returns {Array}
 */
function objToArray(obj) {
  return Object.keys(obj).map(key => obj[key]);
}
/**
 * return only defined properties of object
 * @param  {Object} obj
 * @returns {obj}
 */


function definedOnly(obj) {
  var copy = _objectSpread({}, obj);

  for (var key in copy) {
    if (copy[key] === undefined) {
      delete copy[key];
    }
  }

  return copy;
}
/**
 * Promise that resolves after duration seconds
 * @param  {Number} duration
 * @returns {Promise}
 */


function wait(duration) {
  return new Promise(resolve => setTimeout(resolve, duration));
}
/**
 * Throw error if value not instance of validInstance
 * @param  {Any} value
 * @param  {Any} validInstance
 * @param  {Boolean} noError
 * @returns {Boolean}
 */


function validateInstance(value, validInstance, noError) {
  var isInstance = typeof validInstance === 'function' && value instanceof validInstance;

  if (!isInstance && !noError) {
    throw new Error("Expected instance of ".concat(validInstance.name));
  }

  return isInstance;
}
/**
 * returns first defined argument
 * @param  {...Any} args [description]
 * @returns {Any}         [description]
 */


function firstDefined() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var arg of args) {
    if (arg !== undefined) {
      return arg;
    }
  }

  return undefined;
}
/**
 * dynamically select specific props of objects
 * @param  {Object} obj
 * @param  {Array} propNames
 * @returns {obj}
 */


function selectProps(obj, propNames) {
  var copy = _objectSpread({}, obj);

  var out = {};

  for (var key of propNames) {
    out[key] = copy[key];
  }

  return out;
}
/**
 * merge props into an object without creating new object
 * @param  {Object} obj
 * @param  {...Object} objectsToMerge
 * @param  {Object} props
 */


function merge(obj) {
  for (var _len2 = arguments.length, objectsToMerge = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    objectsToMerge[_key2 - 1] = arguments[_key2];
  }

  for (var objectToMerge of objectsToMerge) {
    for (var key in objectToMerge) {
      obj[key] = objectToMerge[key];
    }
  }
}