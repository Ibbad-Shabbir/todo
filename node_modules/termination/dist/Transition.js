"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bezierEasing = _interopRequireDefault(require("bezier-easing"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Transition {
  constructor(object, steps) {
    var {
      loop = false,
      alternate = false,
      loopInterval = 0
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var onFinish = arguments.length > 3 ? arguments[3] : undefined;

    _defineProperty(this, "DEFAULT_FUNCTIONS", {
      linear: () => {
        return t => t;
      },
      ease: () => {
        var ease = new _bezierEasing.default(0.25, 0.1, 0.25, 1.0);
        return t => ease(t);
      },
      'ease-in': () => {
        var ease = new _bezierEasing.default(0.42, 0.0, 1.0, 1.0);
        return t => ease(t);
      },
      'ease-out': () => {
        var ease = new _bezierEasing.default(0.0, 0.0, 0.58, 1.0);
        return t => ease(t);
      },
      'ease-in-out': () => {
        var ease = new _bezierEasing.default(0.42, 0.0, 0.58, 1.0);
        return t => ease(t);
      }
    });

    this.state = {
      isRunning: false,
      loop: loop,
      alternate: alternate,
      loopInterval: loopInterval,
      promise: {},
      callBack: null,
      object: object,
      steps: steps,
      currentStep: {
        index: 0,
        loaded: false
      }
    };
    this.onFinish = onFinish;
  }

  setState(data) {
    var newState = _objectSpread(_objectSpread({}, this.state), (0, _utils.definedOnly)(data));

    this.state = newState;
    return newState;
  }

  applySteps(timePassed) {
    var _this = this;

    var {
      object,
      steps,
      currentStep,
      isRunning,
      loop,
      alternate,
      loopInterval
    } = this.state;

    if (!isRunning || isRunning === -1) {
      return;
    }

    var newCurrentStep = currentStep;

    if (!newCurrentStep.loaded) {
      (function () {
        var step = steps[newCurrentStep.index];
        var {
          duration,
          func: generalFunc,
          props: stepProps
        } = step;
        var propNames = Object.keys(stepProps);
        var current = (0, _utils.selectProps)(object.state, propNames);
        var final = (0, _utils.selectProps)(stepProps, propNames);
        var transformers = [];

        var _loop = function _loop(key) {
          var finalProp = final[key];
          var currentProp = current[key];

          if (!finalProp.func && !generalFunc || finalProp.noFunc) {
            return "continue";
          }

          var finalValue = finalProp.value || finalProp;
          var currentValue = currentProp.value || currentProp;
          var coef = finalValue - currentValue;
          var func = finalProp.func || generalFunc;
          var validatedFunc = void 0;

          if (typeof func === 'string') {
            validatedFunc = _this.DEFAULT_FUNCTIONS[func]();
          } else if (typeof func === 'function') {
            validatedFunc = func;
          } else {
            throw new Error('Invalid transition function');
          }

          transformers[key] = t => {
            var seconds = t / duration;
            return validatedFunc(seconds) * coef;
          };
        };

        for (var key in final) {
          var _ret = _loop(key);

          if (_ret === "continue") continue;
        }

        newCurrentStep = _objectSpread(_objectSpread({}, newCurrentStep), {}, {
          loaded: true,
          time: 0,
          duration: duration,
          current: current,
          final: final,
          transformers: transformers
        });

        if (steps[0] && steps[0].isDelay ? newCurrentStep.index === 1 : newCurrentStep.index === 0) {
          newCurrentStep.initial = current;
        }

        _this.setState({
          currentStep: newCurrentStep
        });
      })();
    }

    var {
      transformers,
      initial,
      final,
      time,
      current,
      duration,
      index: stepIndex
    } = newCurrentStep;
    var newTime = time + timePassed;
    var transformedProps = {};

    for (var key in transformers) {
      var transformer = transformers[key];
      var diff = transformer(newTime);

      if (!diff) {
        continue;
      }

      transformedProps[key] = current[key] + diff;
    }

    if (newTime >= duration) {
      var nexStepIndex = stepIndex + 1;
      var isFinished = !steps[nexStepIndex];
      var newLoop = loop;
      var newSteps = steps;
      object.update(final);

      if (isFinished) {
        newSteps = steps.filter(step => !step.isDelay);

        if (loop === true || loop > 1) {
          if (alternate) {
            var prevSteps = [...newSteps];
            var length = prevSteps.length;
            newSteps = newSteps.slice(0, -1).reverse();
            newSteps.push({
              props: initial
            });
            newSteps = newSteps.map((step, stepIndex) => _objectSpread(_objectSpread({}, prevSteps[length - 1 - stepIndex]), {}, {
              props: step.props
            }));
          }

          newSteps = [{
            props: alternate ? {} : initial,
            duration: loopInterval,
            isDelay: true
          }, ...newSteps];

          if (loop && typeof loop === 'number') {
            newLoop = loop - 1;
          }
        } else {
          this.end();
          return;
        }
      }

      this.setState({
        currentStep: _objectSpread(_objectSpread({}, newCurrentStep), {}, {
          index: isFinished ? 0 : nexStepIndex,
          loaded: false
        }),
        loop: newLoop,
        steps: newSteps
      });
      return;
    }

    object.update(transformedProps);
    this.setState({
      currentStep: _objectSpread(_objectSpread({}, newCurrentStep), {}, {
        time: newTime
      })
    });
  }

  runTransition(callBack) {
    var {
      isRunning
    } = this.state;

    if (isRunning === true) {
      throw new Error('Already running');
    }

    var promise = new Promise((resolve, reject) => {
      this.setState({
        promise: {
          resolve,
          reject
        },
        callBack: callBack,
        isRunning: true
      });
    });
    return promise;
  }

  pauseTransition(isAuto) {
    var {
      isRunning
    } = this.state;

    if (!isRunning || isRunning === -1) {
      return;
    }

    this.setState({
      isRunning: isAuto ? -1 : false
    });
  }

  resumeTransition(isAuto) {
    var {
      isRunning
    } = this.state;

    if (isRunning === true) {
      return;
    }

    if (isAuto && isRunning !== -1) {
      return;
    }

    this.setState({
      isRunning: true
    });
  }

  endTransition() {
    var {
      promise,
      callBack
    } = this.state;

    if (promise && promise.resolve) {
      promise.resolve();
    }

    if (callBack) {
      callBack();
    }

    if (this.onFinish) {
      this.onFinish();
    }
  }
  /**
   * External
   */


  apply(timePassed) {
    return this.applySteps(timePassed);
  }

  run(callBack) {
    return this.runTransition(callBack);
  }

  pause(isAuto) {
    return this.pauseTransition(isAuto);
  }

  resume(isAuto) {
    return this.resumeTransition(isAuto);
  }

  end() {
    return this.endTransition();
  }

}

exports.default = Transition;